{
  "_args": [
    [
      "tcomb-form-native",
      "/Users/weiwei/SomethingNew"
    ]
  ],
  "_from": "tcomb-form-native@*",
  "_id": "tcomb-form-native@0.6.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/tcomb-form-native",
  "_nodeVersion": "5.5.0",
  "_npmOperationalInternal": {
    "host": "packages-16-east.internal.npmjs.com",
    "tmp": "tmp/tcomb-form-native-0.6.0.tgz_1469525052609_0.08399842237122357"
  },
  "_npmUser": {
    "email": "giulio.canti@gmail.com",
    "name": "gcanti"
  },
  "_npmVersion": "3.3.12",
  "_phantomChildren": {},
  "_requested": {
    "name": "tcomb-form-native",
    "raw": "tcomb-form-native",
    "rawSpec": "",
    "scope": null,
    "spec": "*",
    "type": "range"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/tcomb-form-native/-/tcomb-form-native-0.6.0.tgz",
  "_shasum": "fa7dad23b9c6411b06b2dd155a402b975ecfa47a",
  "_shrinkwrap": null,
  "_spec": "tcomb-form-native",
  "_where": "/Users/weiwei/SomethingNew",
  "author": {
    "email": "giulio.canti@gmail.com",
    "name": "Giulio Canti"
  },
  "bugs": {
    "url": "https://github.com/gcanti/tcomb-form-native/issues"
  },
  "dependencies": {
    "tcomb-validation": "^3.0.0"
  },
  "description": "react-native powered UI library for developing forms writing less code",
  "devDependencies": {
    "babel": "5.8.34",
    "babel-core": "5.8.34",
    "eslint": "0.23.0",
    "eslint-plugin-react": "2.5.2",
    "react": "^15.0.0",
    "tape": "3.5.0"
  },
  "directories": {},
  "dist": {
    "shasum": "fa7dad23b9c6411b06b2dd155a402b975ecfa47a",
    "tarball": "https://registry.npmjs.org/tcomb-form-native/-/tcomb-form-native-0.6.0.tgz"
  },
  "gitHead": "b7c3c27ae545972c025b7433d59fe9734a3f808f",
  "homepage": "https://github.com/gcanti/tcomb-form-native",
  "keywords": [
    "form",
    "forms",
    "react",
    "react-component",
    "react-native",
    "tcomb"
  ],
  "license": "MIT",
  "main": "index.js",
  "maintainers": [
    {
      "email": "giulio.canti@gmail.com",
      "name": "gcanti"
    }
  ],
  "name": "tcomb-form-native",
  "optionalDependencies": {},
  "readme": "[![build status](https://img.shields.io/travis/gcanti/tcomb-form-native/master.svg?style=flat-square)](https://travis-ci.org/gcanti/tcomb-form-native)\n[![dependency status](https://img.shields.io/david/gcanti/tcomb-form-native.svg?style=flat-square)](https://david-dm.org/gcanti/tcomb-form-native)\n![npm downloads](https://img.shields.io/npm/dm/tcomb-form-native.svg)\n\n# Setup\n\n```\nnpm install tcomb-form-native\n```\n\n# Supported react-native versions\n\n- tcomb-form-native ^0.5: react-native >= 0.25.0\n- tcomb-form-native ^0.4: react-native >= 0.20.0\n- tcomb-form-native ^0.3: react-native < 0.13.0\n\n### Domain Driven Forms\n\nThe [tcomb library](https://github.com/gcanti/tcomb) provides a concise but expressive way to define domain models in JavaScript.\n\nThe [tcomb-validation library](https://github.com/gcanti/tcomb-validation) builds on tcomb, providing validation functions for tcomb domain models.\n\nThis library builds on those two and the awesome react-native.\n\n### Benefits\n\nWith **tcomb-form-native** you simply call `<Form type={Model} />` to generate a form based on that domain model. What does this get you?\n\n1. Write a lot less code\n2. Usability and accessibility for free (automatic labels, inline validation, etc)\n3. No need to update forms when domain model changes\n\n### JSON Schema support\n\nJSON Schemas are also supported via the (tiny) [tcomb-json-schema library](https://github.com/gcanti/tcomb-json-schema).\n\n**Note**. Please use tcomb-json-schema ^0.2.5.\n\n### Pluggable look and feel\n\nThe look and feel is customizable via react-native stylesheets and *templates* (see documentation).\n\n### Screencast\n\nhttp://react.rocks/example/tcomb-form-native\n\n### Example App\n\n[https://github.com/bartonhammond/snowflake](https://github.com/bartonhammond/snowflake) React-Native, Tcomb, Redux, Parse.com, Jest - 88% coverage\n\n# Example\n\n```js\n// index.ios.js\n\n'use strict';\n\nvar React = require('react-native');\nvar t = require('tcomb-form-native');\nvar { AppRegistry, StyleSheet, Text, View, TouchableHighlight } = React;\n\nvar Form = t.form.Form;\n\n// here we are: define your domain model\nvar Person = t.struct({\n  name: t.String,              // a required string\n  surname: t.maybe(t.String),  // an optional string\n  age: t.Number,               // a required number\n  rememberMe: t.Boolean        // a boolean\n});\n\nvar options = {}; // optional rendering options (see documentation)\n\nvar AwesomeProject = React.createClass({\n\n  onPress: function () {\n    // call getValue() to get the values of the form\n    var value = this.refs.form.getValue();\n    if (value) { // if validation fails, value will be null\n      console.log(value); // value here is an instance of Person\n    }\n  },\n\n  render: function() {\n    return (\n      <View style={styles.container}>\n        {/* display */}\n        <Form\n          ref=\"form\"\n          type={Person}\n          options={options}\n        />\n        <TouchableHighlight style={styles.button} onPress={this.onPress} underlayColor='#99d9f4'>\n          <Text style={styles.buttonText}>Save</Text>\n        </TouchableHighlight>\n      </View>\n    );\n  }\n});\n\nvar styles = StyleSheet.create({\n  container: {\n    justifyContent: 'center',\n    marginTop: 50,\n    padding: 20,\n    backgroundColor: '#ffffff',\n  },\n  title: {\n    fontSize: 30,\n    alignSelf: 'center',\n    marginBottom: 30\n  },\n  buttonText: {\n    fontSize: 18,\n    color: 'white',\n    alignSelf: 'center'\n  },\n  button: {\n    height: 36,\n    backgroundColor: '#48BBEC',\n    borderColor: '#48BBEC',\n    borderWidth: 1,\n    borderRadius: 8,\n    marginBottom: 10,\n    alignSelf: 'stretch',\n    justifyContent: 'center'\n  }\n});\n\nAppRegistry.registerComponent('AwesomeProject', () => AwesomeProject);\n```\n\n**Output:**\n\n(Labels are automatically generated)\n\n![Result](docs/images/result.png)\n\n**Ouput after a validation error:**\n\n![Result after a validation error](docs/images/validation.png)\n\n# API\n\n## `getValue()`\n\nReturns `null` if the validation failed, an instance of your model otherwise.\n\n> **Note**. Calling `getValue` will cause the validation of all the fields of the form, including some side effects like highlighting the errors.\n\n## `validate()`\n\nReturns a `ValidationResult` (see [tcomb-validation](https://github.com/gcanti/tcomb-validation) for a reference documentation).\n\n## Adding a default value and listen to changes\n\nThe `Form` component behaves like a [controlled component](https://facebook.github.io/react/docs/forms.html):\n\n```js\nvar Person = t.struct({\n  name: t.String,\n  surname: t.maybe(t.String)\n});\n\nvar AwesomeProject = React.createClass({\n\n  getInitialState() {\n    return {\n      value: {\n        name: 'Giulio',\n        surname: 'Canti'\n      }\n    };\n  },\n\n  onChange(value) {\n    this.setState({value});\n  },\n\n  onPress: function () {\n    var value = this.refs.form.getValue();\n    if (value) {\n      console.log(value);\n    }\n  },\n\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <Form\n          ref=\"form\"\n          type={Person}\n          value={this.state.value}\n          onChange={this.onChange}\n        />\n        <TouchableHighlight style={styles.button} onPress={this.onPress} underlayColor='#99d9f4'>\n          <Text style={styles.buttonText}>Save</Text>\n        </TouchableHighlight>\n      </View>\n    );\n  }\n});\n```\n\nThe `onChange` handler has the following signature:\n\n```\n(raw: any, path: Array<string | number>) => void\n```\n\nwhere\n\n- `raw` contains the current raw value of the form (can be an invalid value for your model)\n- `path` is the path to the field triggering the change\n\n> **Warning**. tcomb-form-native uses `shouldComponentUpdate` aggressively. In order to ensure that tcomb-form-native detect any change to `type`, `options` or `value` props you have to change references:\n\n## Disable a field based on another field's value\n\n```js\nvar Type = t.struct({\n  disable: t.Boolean, // if true, name field will be disabled\n  name: t.String\n});\n\n// see the \"Rendering options\" section in this guide\nvar options = {\n  fields: {\n    name: {}\n  }\n};\n\nvar AwesomeProject = React.createClass({\n\n  getInitialState() {\n    return {\n      options: options,\n      value: null\n    };\n  },\n\n  onChange(value) {\n    // tcomb immutability helpers\n    // https://github.com/gcanti/tcomb/blob/master/GUIDE.md#updating-immutable-instances\n    var options = t.update(this.state.options, {\n      fields: {\n        name: {\n          editable: {'$set': !value.disable}\n        }\n      }\n    });\n    this.setState({options: options, value: value});\n  },\n\n  onPress: function () {\n    var value = this.refs.form.getValue();\n    if (value) {\n      console.log(value);\n    }\n  },\n\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <Form\n          ref=\"form\"\n          type={Type}\n          options={this.state.options}\n          value={this.state.value}\n          onChange={this.onChange}\n        />\n        <TouchableHighlight style={styles.button} onPress={this.onPress} underlayColor='#99d9f4'>\n          <Text style={styles.buttonText}>Save</Text>\n        </TouchableHighlight>\n      </View>\n    );\n  }\n\n});\n```\n\n## How to get access to a field\n\nYou can get access to a field with the `getComponent(path)` API:\n\n```js\nvar Person = t.struct({\n  name: t.String,\n  surname: t.maybe(t.String),\n  age: t.Number,\n  rememberMe: t.Boolean\n});\n\nvar AwesomeProject = React.createClass({\n\n  componentDidMount() {\n    // give focus to the name textbox\n    this.refs.form.getComponent('name').refs.input.focus();\n  },\n\n  onPress: function () {\n    var value = this.refs.form.getValue();\n    if (value) {\n      console.log(value);\n    }\n  },\n\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <Form\n          ref=\"form\"\n          type={Person}\n        />\n        <TouchableHighlight style={styles.button} onPress={this.onPress} underlayColor='#99d9f4'>\n          <Text style={styles.buttonText}>Save</Text>\n        </TouchableHighlight>\n      </View>\n    );\n  }\n});\n```\n\n## How to clear form after submit\n\n```js\nvar Person = t.struct({\n  name: t.String,\n  surname: t.maybe(t.String),\n  age: t.Number,\n  rememberMe: t.Boolean\n});\n\nvar AwesomeProject = React.createClass({\n\n  getInitialState() {\n    return { value: null };\n  },\n\n  onChange(value) {\n    this.setState({ value });\n  },\n\n  clearForm() {\n    // clear content from all textbox\n    this.setState({ value: null });\n  },\n\n  onPress: function () {\n    var value = this.refs.form.getValue();\n    if (value) {\n      console.log(value);\n      // clear all fields after submit\n      this.clearForm();\n    }\n  },\n\n  render: function() {\n    return (\n      <View style={styles.container}>\n        <Form\n          ref=\"form\"\n          type={Person}\n          value={this.state.value}\n          onChange={this.onChange.bind(this)}\n        />\n        <TouchableHighlight style={styles.button} onPress={this.onPress} underlayColor='#99d9f4'>\n          <Text style={styles.buttonText}>Save</Text>\n        </TouchableHighlight>\n      </View>\n    );\n  }\n});\n```\n\n## Dynamic forms example: how to change a form based on selection\n\nSay I have an iOS Picker, depending on which option is selected in this picker I want the next component to either be a checkbox or a textbox:\n\n```js\nconst Country = t.enums({\n  'IT': 'Italy',\n  'US': 'Unisted States'\n}, 'Country');\n\nvar AwesomeProject = React.createClass({\n\n  // returns the suitable type based on the form value\n  getType(value) {\n    if (value.country === 'IT') {\n      return t.struct({\n        country: Country,\n        rememberMe: t.Boolean\n      });\n    } else if (value.country === 'US') {\n      return t.struct({\n        country: Country,\n        name: t.String\n      });\n    } else {\n      return t.struct({\n        country: Country\n      });\n    }\n  },\n\n  getInitialState() {\n    const value = {};\n    return { value, type: this.getType(value) };\n  },\n\n  onChange(value) {\n    // recalculate the type only if strictly necessary\n    const type = value.country !== this.state.value.country ?\n      this.getType(value) :\n      this.state.type;\n    this.setState({ value, type });\n  },\n\n  onPress() {\n    var value = this.refs.form.getValue();\n    if (value) {\n      console.log(value);\n    }\n  },\n\n  render() {\n\n    return (\n      <View style={styles.container}>\n        <t.form.Form\n          ref=\"form\"\n          type={this.state.type}\n          value={this.state.value}\n          onChange={this.onChange}\n        />\n        <TouchableHighlight style={styles.button} onPress={this.onPress} underlayColor='#99d9f4'>\n          <Text style={styles.buttonText}>Save</Text>\n        </TouchableHighlight>\n      </View>\n    );\n  }\n});\n```\n\n# Types\n\n### Required field\n\nBy default fields are required:\n\n```js\nvar Person = t.struct({\n  name: t.String,    // a required string\n  surname: t.String  // a required string\n});\n```\n\n### Optional field\n\nIn order to create an optional field, wrap the field type with the `t.maybe` combinator:\n\n```js\nvar Person = t.struct({\n  name: t.String,\n  surname: t.String,\n  email: t.maybe(t.String) // an optional string\n});\n```\n\nThe postfix `\" (optional)\"` is automatically added to optional fields.\n\nYou can customise the postfix value or setting a postfix for required fields:\n\n```js\nt.form.Form.i18n = {\n  optional: '',\n  required: ' (required)' // inverting the behaviour: adding a postfix to the required fields\n};\n```\n\n### Numbers\n\nIn order to create a numeric field, use the `t.Number` type:\n\n```js\nvar Person = t.struct({\n  name: t.String,\n  surname: t.String,\n  email: t.maybe(t.String),\n  age: t.Number // a numeric field\n});\n```\n\ntcomb-form-native will convert automatically numbers to / from strings.\n\n### Booleans\n\nIn order to create a boolean field, use the `t.Boolean` type:\n\n```js\nvar Person = t.struct({\n  name: t.String,\n  surname: t.String,\n  email: t.maybe(t.String),\n  age: t.Number,\n  rememberMe: t.Boolean // a boolean field\n});\n```\n\nBooleans are displayed as `SwitchIOS`s.\n\n### Dates\n\nIn order to create a date field, use the `t.Date` type:\n\n```js\nvar Person = t.struct({\n  name: t.String,\n  surname: t.String,\n  email: t.maybe(t.String),\n  age: t.Number,\n  birthDate: t.Date // a date field\n});\n```\n\nDates are displayed as `DatePickerIOS`s under iOS and `DatePickerAndroid` or `TimePickerAndroid` under Android, depending on the `mode` selected (`date` or `time`).\n\n#### iOS date `config` option\n\nThe bundled template will render an iOS `UIDatePicker` component, but collapsed into a touchable component in order to improve usability. A `config` object can be passed to customize it with the following parameters:\n\n| Key | Value |\n|-----|-------|\n| `animation` | The animation to collapse the date picker. Defaults to `Animated.timing`. |\n| `animationConfig` | The animation configuration object. Defaults to `{duration: 200}` for the default animation. |\n| `format` | A `(date) => String(date)` kind of function to provide a custom date format parsing to display the value. Optional, defaults to `(date) => String(date)`.\n\nFor the collapsible customization, look at the `dateTouchable` and `dateValue` keys in the stylesheet file.\n\n#### Android date `config` option\n\nWhen using a `t.Date` type in Android, it can be configured through a `config` option that take the following parameters:\n\n| Key | Value |\n|-----|-------|\n| ``background`` | Determines the type of background drawable that's going to be used to display feedback. Optional, defaults to ``TouchableNativeFeedback.SelectableBackground``. |\n| ``format`` | A ``(date) => String(date)`` kind of function to provide a custom date format parsing to display the value. Optional, defaults to ``(date) => String(date)``.\n\n### Enums\n\nIn order to create an enum field, use the `t.enums` combinator:\n\n```js\nvar Gender = t.enums({\n  M: 'Male',\n  F: 'Female'\n});\n\nvar Person = t.struct({\n  name: t.String,\n  surname: t.String,\n  email: t.maybe(t.String),\n  age: t.Number,\n  rememberMe: t.Boolean,\n  gender: Gender // enum\n});\n```\n\nEnums are displayed as `Picker`s.\n\n#### iOS select `config` option\n\nThe bundled template will render an iOS `UIPickerView` component, but collapsed into a touchable component in order to improve usability. A `config` object can be passed to customize it with the following parameters:\n\n| Key | Value |\n|-----|-------|\n| `animation` | The animation to collapse the date picker. Defaults to `Animated.timing`. |\n| `animationConfig` | The animation configuration object. Defaults to `{duration: 200}` for the default animation. |\n\nFor the collapsible customization, look at the `pickerTouchable` and `pickerValue` keys in the stylesheet file.\n\n### Refinements\n\nA *predicate* is a function with the following signature:\n\n```\n(x: any) => boolean\n```\n\nYou can refine a type with the `t.refinement(type, predicate)` combinator:\n\n```js\n// a type representing positive numbers\nvar Positive = t.refinement(t.Number, function (n) {\n  return n >= 0;\n});\n\nvar Person = t.struct({\n  name: t.String,\n  surname: t.String,\n  email: t.maybe(t.String),\n  age: Positive, // refinement\n  rememberMe: t.Boolean,\n  gender: Gender\n});\n```\n\nSubtypes allow you to express any custom validation with a simple predicate.\n\n# Rendering options\n\nIn order to customize the look and feel, use an `options` prop:\n\n```js\n<Form type={Model} options={options} />\n```\n\n## Form component\n\n### Labels and placeholders\n\nBy default labels are automatically generated. You can turn off this behaviour or override the default labels\non field basis.\n\n```js\nvar options = {\n  label: 'My struct label' // <= form legend, displayed before the fields\n};\n\nvar options = {\n  fields: {\n    name: {\n      label: 'My name label' // <= label for the name field\n    }\n  }\n};\n```\n\nIn order to automatically generate default placeholders, use the option `auto: 'placeholders'`:\n\n```js\nvar options = {\n  auto: 'placeholders'\n};\n\n<Form type={Person} options={options} />\n```\n\n![Placeholders](docs/images/placeholders.png)\n\nSet `auto: 'none'` if you don't want neither labels nor placeholders.\n\n```js\nvar options = {\n  auto: 'none'\n};\n```\n\n### Fields order\n\nYou can sort the fields with the `order` option:\n\n```js\nvar options = {\n  order: ['name', 'surname', 'rememberMe', 'gender', 'age', 'email']\n};\n```\n\n### Default values\n\nYou can set the default values passing a `value` prop to the `Form` component:\n\n```js\nvar value = {\n  name: 'Giulio',\n  surname: 'Canti',\n  age: 41,\n  gender: 'M'\n};\n\n<Form type={Model} value={value} />\n```\n\n### Fields configuration\n\nYou can configure each field with the `fields` option:\n\n```js\nvar options = {\n  fields: {\n    name: {\n      // name field configuration here..\n    },\n    surname: {\n      // surname field configuration here..\n    }\n  }\n};\n```\n\n## Textbox component\n\nImplementation: `TextInput`\n\n**Tech note.** Values containing only white spaces are converted to `null`.\n\n### Placeholder\n\nYou can set the placeholder with the `placeholder` option:\n\n```js\nvar options = {\n  fields: {\n    name: {\n      placeholder: 'Your placeholder here'\n    }\n  }\n};\n```\n\n### Label\n\nYou can set the label with the `label` option:\n\n```js\nvar options = {\n  fields: {\n    name: {\n      label: 'Insert your name'\n    }\n  }\n};\n```\n\n### Help message\n\nYou can set a help message with the `help` option:\n\n```js\nvar options = {\n  fields: {\n    name: {\n      help: 'Your help message here'\n    }\n  }\n};\n```\n\n![Help](docs/images/help.png)\n\n### Error messages\n\nYou can add a custom error message with the `error` option:\n\n```js\nvar options = {\n  fields: {\n    email: {\n      // you can use strings or JSX\n      error: 'Insert a valid email'\n    }\n  }\n};\n```\n\n![Help](docs/images/error.png)\n\ntcomb-form-native will display the error message when the field validation fails.\n\n`error` can also be a function with the following signature:\n\n```\n(value, path, context) => ?(string | ReactElement)\n```\n\nwhere\n\n- `value` is an object containing the current form value.\n- `path` is the path of the value being validated\n- `context` is the value of the `context` prop. Also it contains a reference to the component options.\n\nThe value returned by the function will be used as error message.\n\nIf you want to show the error message onload, add the `hasError` option:\n\n```js\nvar options = {\n  hasError: true,\n  error: <i>A custom error message</i>\n};\n```\n\nAnother way is to add a:\n\n```\ngetValidationErrorMessage(value, path, context)\n```\n\nstatic function to a type, where:\n\n- `value` is the (parsed) current value of the component.\n- `path` is the path of the value being validated\n- `context` is the value of the `context` prop. Also it contains a reference to the component options.\n\n\n```js\nvar Age = t.refinement(t.Number, function (n) { return n >= 18; });\n\n// if you define a getValidationErrorMessage function, it will be called on validation errors\nAge.getValidationErrorMessage = function (value, path, context) {\n  return 'bad age, locale: ' + context.locale;\n};\n\nvar Schema = t.struct({\n  age: Age\n});\n\n...\n\n<t.form.Form\n  ref=\"form\"\n  type={Schema}\n  context={{locale: 'it-IT'}}\n/>\n```\n\nYou can even define `getValidationErrorMessage` on the supertype in order to be DRY:\n\n```js\nt.Number.getValidationErrorMessage = function (value, path, context) {\n  return 'bad number';\n};\n\nAge.getValidationErrorMessage = function (value, path, context) {\n  return 'bad age, locale: ' + context.locale;\n};\n```\n\n### Other standard options\n\nThe following standard options are available (see http://facebook.github.io/react-native/docs/textinput.html):\n\n- `autoCapitalize`\n- `autoCorrect`\n- `autoFocus`\n- `bufferDelay`\n- `clearButtonMode`\n- `editable`\n- `enablesReturnKeyAutomatically`\n- `keyboardType`\n- `maxLength`\n- `multiline`\n- `numberOfLines`\n- `onBlur`\n- `onEndEditing`\n- `onFocus`\n- `onSubmitEditing`\n- `password`\n- `placeholderTextColor`\n- `returnKeyType`\n- `selectTextOnFocus`\n- `secureTextEntry`\n- `selectionState`\n- `textAlign`\n- `textAlignVertical`\n- `underlineColorAndroid`\n\n## Checkbox component\n\nImplementation: `SwitchIOS`\n\nThe following options are similar to the `Textbox` component's ones:\n\n- `label`\n- `help`\n- `error`\n\n### Other standard options\n\nThe following standard options are available (see http://facebook.github.io/react-native/docs/switchios.html):\n\n- `disabled`\n- `onTintColor`\n- `thumbTintColor`\n- `tintColor`\n\n## Select component\n\nImplementation: `PickerIOS`\n\nThe following options are similar to the `Textbox` component's ones:\n\n- `label`\n- `help`\n- `error`\n\n### `nullOption` option\n\nYou can customize the null option with the `nullOption` option:\n\n```js\nvar options = {\n  fields: {\n    gender: {\n      nullOption: {value: '', label: 'Choose your gender'}\n    }\n  }\n};\n```\n\nYou can remove the null option setting the `nullOption` option to `false`.\n\n**Warning**: when you set `nullOption = false` you must also set the Form's `value` prop for the select field.\n\n**Tech note.** A value equal to `nullOption.value` (default `''`) is converted to `null`.\n\n### Options order\n\nYou can sort the options with the `order` option:\n\n```js\nvar options = {\n  fields: {\n    gender: {\n      order: 'asc' // or 'desc'\n    }\n  }\n};\n```\n\n## DatePicker component\n\nImplementation: `DatePickerIOS`\n\n### Example\n\n```js\nvar Person = t.struct({\n  name: t.String,\n  birthDate: t.Date\n});\n```\n\nThe following options are similar to the `Textbox` component's ones:\n\n- `label`\n- `help`\n- `error`\n\n### Other standard options\n\nThe following standard options are available (see http://facebook.github.io/react-native/docs/datepickerios.html):\n\n- `maximumDate`,\n- `minimumDate`,\n- `minuteInterval`,\n- `mode`,\n- `timeZoneOffsetInMinutes`\n\n## Hidden Component\n\nFor any component, you can set the field with the `hidden` option:\n\n```js\nvar options = {\n  fields: {\n    name: {\n      hidden: true\n    }\n  }\n};\n```\n\nThis will completely skip the rendering of the component, while the default value will be available for validation purposes.\n\n# Unions\n\n**Code Example**\n\n```js\nconst AccountType = t.enums.of([\n  'type 1',\n  'type 2',\n  'other'\n], 'AccountType')\n\nconst KnownAccount = t.struct({\n  type: AccountType\n}, 'KnownAccount')\n\n// UnknownAccount extends KnownAccount so it owns also the type field\nconst UnknownAccount = KnownAccount.extend({\n  label: t.String,\n}, 'UnknownAccount')\n\n// the union\nconst Account = t.union([KnownAccount, UnknownAccount], 'Account')\n\n// the final form type\nconst Type = t.list(Account)\n\nconst options = {\n  item: [ // one options object for each concrete type of the union\n    {\n      label: 'KnownAccount'\n    },\n    {\n      label: 'UnknownAccount'\n    }\n  ]\n}\n```\n\nGenerally `tcomb`'s unions require a `dispatch` implementation in order to select the suitable type constructor for a given value and this would be the key in this use case:\n\n```js\n// if account type is 'other' return the UnknownAccount type\nAccount.dispatch = value => value && value.type === 'other' ? UnknownAccount : KnownAccount\n```\n\n# Lists\n\nYou can handle a list with the `t.list` combinator:\n\n```js\nconst Person = t.struct({\n  name: t.String,\n  tags: t.list(t.String) // a list of strings\n});\n```\n\n## Items configuration\n\nTo configure all the items in a list, set the `item` option:\n\n```js\nconst Person = t.struct({\n  name: t.String,\n  tags: t.list(t.String) // a list of strings\n});\n\nconst options = {\n  fields: { // <= Person options\n    tags: {\n      item: { // <= options applied to each item in the list\n        label: 'My tag'\n      }\n    }\n  }\n});\n```\n\n## Nested structures\n\nYou can nest lists and structs at an arbitrary level:\n\n```js\nconst Person = t.struct({\n  name: t.String,\n  surname: t.String\n});\n\nconst Persons = t.list(Person);\n```\n\n## Internationalization\n\nYou can override the default language (english) with the `i18n` option:\n\n```js\nconst options = {\n  i18n: {\n    optional: ' (optional)',\n    required: '',\n    add: 'Add',   // add button\n    remove: '✘',  // remove button\n    up: '↑',      // move up button\n    down: '↓'     // move down button\n  }\n};\n```\n\n## Buttons configuration\n\nYou can prevent operations on lists with the following options:\n\n- `disableAdd`: (default `false`) prevents adding new items\n- `disableRemove`: (default `false`) prevents removing existing items\n- `disableOrder`: (default `false`) prevents sorting existing items\n\n```js\nconst options = {\n  disableOrder: true\n};\n```\n\n## List with Dynamic Items (Different structs based on selected value)\n\nLists of different types are not supported. This is because a `tcomb`'s list, by definition, contains only values of the same type. You can define a union though:\n\n```js\nconst AccountType = t.enums.of([\n  'type 1',\n  'type 2',\n  'other'\n], 'AccountType')\n\nconst KnownAccount = t.struct({\n  type: AccountType\n}, 'KnownAccount')\n\n// UnknownAccount extends KnownAccount so it owns also the type field\nconst UnknownAccount = KnownAccount.extend({\n  label: t.String,\n}, 'UnknownAccount')\n\n// the union\nconst Account = t.union([KnownAccount, UnknownAccount], 'Account')\n\n// the final form type\nconst Type = t.list(Account)\n```\n\nGenerally `tcomb`'s unions require a `dispatch` implementation in order to select the suitable type constructor for a given value and this would be the key in this use case:\n\n```js\n// if account type is 'other' return the UnknownAccount type\nAccount.dispatch = value => value && value.type === 'other' ? UnknownAccount : KnownAccount\n```\n\n# Customizations\n\n## Stylesheets\n\nSee also [Stylesheet guide](docs/STYLESHEETS.md).\n\ntcomb-form-native comes with a default style. You can customize the look and feel by setting another stylesheet:\n\n```js\nvar t = require('tcomb-form-native/lib');\nvar i18n = require('tcomb-form-native/lib/i18n/en');\nvar templates = require('tcomb-form-native/lib/templates/bootstrap');\n\n// define a stylesheet (see lib/stylesheets/bootstrap for an example)\nvar stylesheet = {...};\n\n// override globally the default stylesheet\nt.form.Form.stylesheet = stylesheet;\n// set defaults\nt.form.Form.templates = templates;\nt.form.Form.i18n = i18n;\n```\n\nYou can also override the stylesheet locally for selected fields:\n\n```js\nvar Person = t.struct({\n  name: t.String\n});\n\nvar options = {\n  fields: {\n    name: {\n      stylesheet: myCustomStylesheet\n    }\n  }\n};\n```\n\nOr per form:\n\n```js\nvar Person = t.struct({\n  name: t.String\n});\n\nvar options = {\n  stylesheet: myCustomStylesheet\n};\n```\n\nFor a complete example see the default stylesheet https://github.com/gcanti/tcomb-form-native/blob/master/lib/stylesheets/bootstrap.js.\n\n## Templates\n\ntcomb-form-native comes with a default layout, i.e. a bunch of templates, one for each component.\nWhen changing the stylesheet is not enough, you can customize the layout by setting custom templates:\n\n```js\nvar t = require('tcomb-form-native/lib');\nvar i18n = require('tcomb-form-native/lib/i18n/en');\nvar stylesheet = require('tcomb-form-native/lib/stylesheets/bootstrap');\n\n// define the templates (see lib/templates/bootstrap for an example)\nvar templates = {...};\n\n// override globally the default layout\nt.form.Form.templates = templates;\n// set defaults\nt.form.Form.stylesheet = stylesheet;\nt.form.Form.i18n = i18n;\n```\n\nYou can also override the template locally:\n\n```js\nvar Person = t.struct({\n  name: t.String\n});\n\nfunction myCustomTemplate(locals) {\n\n  var containerStyle = {...};\n  var labelStyle = {...};\n  var textboxStyle = {...};\n\n  return (\n    <View style={containerStyle}>\n      <Text style={labelStyle}>{locals.label}</Text>\n      <TextInput style={textboxStyle} />\n    </View>\n  );\n}\n\nvar options = {\n  fields: {\n    name: {\n      template: myCustomTemplate\n    }\n  }\n};\n```\n\nA template is a function with the following signature:\n\n```\n(locals: Object) => ReactElement\n```\n\nwhere `locals` is an object contaning the \"recipe\" for rendering the input and it's built for you by tcomb-form-native.\nLet's see an example: the `locals` object passed in the `checkbox` template:\n\n```js\ntype Message = string | ReactElement\n\n{\n  stylesheet: Object, // the styles to be applied\n  hasError: boolean,  // true if there is a validation error\n  error: ?Message,    // the optional error message to be displayed\n  label: Message,     // the label to be displayed\n  help: ?Message,     // the optional help message to be displayed\n  value: boolean,     // the current value of the checkbox\n  onChange: Function, // the event handler to be called when the value changes\n  config: Object,     // an optional object to pass configuration options to the new template\n\n  ...other input options here...\n\n}\n```\n\nFor a complete example see the default template https://github.com/gcanti/tcomb-form-native/blob/master/lib/templates/bootstrap.\n\n## i18n\n\ntcomb-form-native comes with a default internationalization (English). You can customize the look and feel by setting another i18n:\n\n```js\nvar t = require('tcomb-form-native/lib');\nvar templates = require('tcomb-form-native/lib/templates/bootstrap');\n\n// define a stylesheet (see tcomb-form-native/lib/i18n/en for an example)\nvar i18n = {...};\n\n// override globally the default i18n\nt.form.Form.i18n = i18n;\n// set defaults\nt.form.Form.templates = templates;\nt.form.Form.stylesheet = stylesheet;\n```\n\n## Transformers\n\nSay you want a search textbox which accepts a list of keywords separated by spaces:\n\n```js\nvar Search = t.struct({\n  search: t.list(t.String)\n});\n```\n\ntcomb-form by default will render the `search` field as a list. In order to render a textbox you have to override the default behaviour with the factory option:\n\n```js\nvar options = {\n  fields: {\n    search: {\n      factory: t.form.Textbox\n    }\n  }\n};\n```\n\nThere is a problem though: a textbox handle only strings so we need a way to transform a list in a string and a string in a list: a `Transformer` deals with serialization / deserialization of data and has the following interface:\n\n```js\nvar Transformer = t.struct({\n  format: t.Function, // from value to string, it must be idempotent\n  parse: t.Function   // from string to value\n});\n```\n\nA basic transformer implementation for the search textbox:\n\n```js\nvar listTransformer = {\n  format: function (value) {\n    return Array.isArray(value) ? value.join(' ') : value;\n  },\n  parse: function (str) {\n    return str ? str.split(' ') : [];\n  }\n};\n```\n\nNow you can handle lists using the transformer option:\n\n```js\n// example of initial value\nvar value = {\n  search: ['climbing', 'yosemite']\n};\n\nvar options = {\n  fields: {\n    search: {\n      factory: t.form.Textbox, // tell tcomb-react-native to use the same component for textboxes\n      transformer: listTransformer,\n      help: 'Keywords are separated by spaces'\n    }\n  }\n};\n```\n\n## Custom factories\n\nYou can pack together style, template (and transformers) in a custom component and then you can use it with the `factory` option:\n\n```js\nvar Component = t.form.Component;\n\n// extend the base Component\nclass MyComponent extends Component {\n\n  // this is the only required method to implement\n  getTemplate() {\n    // define here your custom template\n    return function (locals) {\n\n      //return ... jsx ...\n\n    };\n  }\n\n  // you can optionally override the default getLocals method\n  // it will provide the locals param to your template\n  getLocals() {\n\n    // in locals you'll find the default locals:\n    // - path\n    // - error\n    // - hasError\n    // - label\n    // - onChange\n    // - stylesheet\n    var locals = super.getLocals();\n\n    // add here your custom locals\n\n    return locals;\n  }\n\n\n}\n\n// as example of transformer: this is the default transformer for textboxes\nMyComponent.transformer = {\n  format: value => Nil.is(value) ? null : value,\n  parse: value => (t.String.is(value) && value.trim() === '') || Nil.is(value) ? null : value\n};\n\nvar Person = t.struct({\n  name: t.String\n});\n\nvar options = {\n  fields: {\n    name: {\n      factory: MyComponent\n    }\n  }\n};\n```\n\n# Tests\n\n```\nnpm test\n```\n**Note:** If you are using Jest, you will encounter an error which can\nbe fixed w/ a small change to the ```package.json```.\n\nThe error will look similiar to the following:\n```\nError: Cannot find module './datepicker' from 'index.js' at\nResolver.resolveModule\n```\n\nA completely working example ```jest``` setup is shown below w/ the\n[http://facebook.github.io/jest/docs/api.html#modulefileextensions-array-string](http://facebook.github.io/jest/docs/api.html#modulefileextensions-array-string)\nfix added:\n\n```\n  \"jest\": {\n    \"setupEnvScriptFile\": \"./node_modules/react-native/jestSupport/env.js\",\n    \"haste\": {\n      \"defaultPlatform\": \"ios\",\n      \"platforms\": [\n        \"ios\",\n        \"android\"\n      ],\n      \"providesModuleNodeModules\": [\n        \"react-native\"\n      ]\n    },\n    \"testPathIgnorePatterns\": [\n      \"/node_modules/\"\n    ],\n    \"testFileExtensions\": [\n      \"es6\",\n      \"js\"\n    ],\n    \"moduleFileExtensions\": [\n      \"js\",\n      \"json\",\n      \"es6\",\n      \"ios.js\"    <<<<<<<<<<<< this needs to be defined!\n    ],\n    \"unmockedModulePathPatterns\": [\n      \"react\",\n      \"react-addons-test-utils\",\n      \"react-native-router-flux\",\n      \"promise\",\n      \"source-map\",\n      \"key-mirror\",\n      \"immutable\",\n      \"fetch\",\n      \"redux\",\n      \"redux-thunk\",\n      \"fbjs\"\n    ],\n    \"collectCoverage\": false,\n    \"verbose\": true\n    },\n```\n\n# License\n\nMIT\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/gcanti/tcomb-form-native.git"
  },
  "scripts": {
    "lint": "eslint lib",
    "test": "npm run lint && babel-node test"
  },
  "tags": [
    "form",
    "forms",
    "react",
    "react-component",
    "react-native",
    "tcomb"
  ],
  "version": "0.6.0"
}
